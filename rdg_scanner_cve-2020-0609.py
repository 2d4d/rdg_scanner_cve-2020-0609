#!/usr/bin/env python3
#
# Single check to see if the server is RD Gatway
# based on https://raw.githubusercontent.com/trustedsec/cve-2019-19781/master/cve-2019-19781_scanner.py
#

import requests
import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning) # disable warnings
import argparse
from netaddr import IPNetwork
import threading
import time
import subprocess
import re

def asn_to_ip(asn):
    # use ASN listings to enumerate whois information for scanning.
    cidr_list = []
    command = 'whois -h whois.radb.net -- \'-i origin %s\' | grep -Eo "([0-9.]+){4}/[0-9]+" | head' % (asn)
    asn_convert = subprocess.Popen([command], shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    stderr_read = asn_convert.stderr.read().decode('utf-8')
    asn_convert = asn_convert.stdout.read().decode('utf-8').splitlines()

    # if we don't have whois installed
    if "whois: not found" in stderr_read:
        print("[-] In order for ASN looks to work you must have whois installed. Type apt-get install whois as an example on Debian/Ubuntu.")
        sys.exit()
    # iterate through cidr ranges and append them to list to be scanned
    for cidr in asn_convert:
        cidr_list.append(cidr)
    return cidr_list


# we need to do this hack job due to sanitization of urls in the latest version of urllib3
# special thanks to rxwx for the fix
def submit_url(url):
    with requests.Session() as s:
        r = requests.Request(method='GET', url=url)
        prep = r.prepare()
        prep.url = url
        try:
            return s.send(prep, verify=False, timeout=2)
        except:
            # send fails hard on openssl errors like sslv3 only but that shouldn't be in w2012+ anyway
            pass

# our main function for testing
def check_server(target, targetport, verbose):
    try:
        print("Scanning: %s                            " % target, end="\r") # Cleaning up output a little
        url = ("https://%s:%s/RDWeb" % (target,targetport))
        req = submit_url(url)

        # only non-empty pages
        if req:
            cont = str(req.content)
            if (
                    ('RemoteApp and Desktop Connection') in cont or
                    ('RD Web Access') in cont or
                    ('Remote Desktop Services') in cont or
                    ('RemoteApp') in cont or
                    ('RD' in cont and 'Gateway' in cont ) or
                    ('Remote Desktop' in cont and 'Gateway' in cont )
                ):
                print("[\033[91m!\033[0m] This is a RD Gateway: %s       " % (target))
                vulnServers.append(target)
                return 1

            # if we run into something other than RD Gateway
            else:
                if verbose == True: print("[-] Server %s does not appear to be a RD Gateway server." % (target))
                pass

    # handle exception errors due to timeouts
    except requests.ReadTimeout:
        if verbose == True: print("[-] ReadTimeout: Server %s timed out and didn't respond on port: %s." % (target, targetport))
        pass

    except requests.ConnectTimeout:
        if verbose == True: print("[-] ConnectTimeout: Server %s did not respond to a web request or the port (%s) is not open." % (target, targetport))
        pass

    except requests.ConnectionError:
        if verbose == True: print("[-] ConnectionError: Server %s did not respond to a web request or the port (%s) is not open." % (target,targetport))
        pass

    # all other exceptions:
    except requests.exceptions.RequestException as e:
        print(e)

def parse_target_args(target, port, verbose):
    global counter
    global threat
    # cidr lookups for ASN lookups
    if re.match ("as\d\d\d", target, re.IGNORECASE) :
        CIDR_Blocks = asn_to_ip(target)
        for ip_block in CIDR_Blocks:
            for ip in IPNetwork(ip_block):
                thread = threading.Thread(target=check_server, args=(ip,port,verbose))
                thread.start()
                time.sleep(0.05)
            # wait for the threads to complete
            thread.join()

    # if we are iterating through IP addresses to scan CIDR notations
    elif "/" in target:
        for ip in IPNetwork(target):
            counter = counter + 1
            thread = threading.Thread(target=check_server, args=(ip,port,verbose))
            thread.start()
            time.sleep(0.05)

        # wait for the threads to complete
        thread.join()

    # if we are just using 1 IP address
    else:
        counter = counter + 1
        check_server(target, port,verbose)

print("""
  ____  ____     ____       _
 |  _ \|  _ \   / ___| __ _| |_ _____      ____ _ _   _
 | |_) | | | | | |  _ / _` | __/ _ \ \ /\ / / _` | | | |
 |  _ <| |_| | | |_| | (_| | ||  __/\ V  V / (_| | |_| |
 |_| \_\____/   \____|\__,_|\__\___| \_/\_/ \__,_|\__, |
                                                  |___/

RD-Gateway-Scanner on HTTPS ports
(To scan for RD-Gateways on UDP 3391 add "3391" to the DTLS section in nmap-payloads and
use "nmap -Pn -p 3391 -sU")
You can use CIDR notations as well for example: 192.168.1.1/24
You can use hostnames instead of IP addresses also.
You can also use a file with IP addresses generated by an external tool.

Debian/Kali needs: apt-get install python3-netaddr

Example: python3 rdg_scanner_cve-2020-0609.py 192.168.1.1/24 443
Example2: python3 rdg_scanner_cve-2020-0609.py 192.168.1.1 443
Example3: python3 rdg_scanner_cve-2020-0609.py fakewebsiteaddress.com 443
Example4: python3 rdg_scanner_cve-2020-0609.py as15169 443
Example5: python3 rdg_scanner_cve-2020-0609.py 192.168.1.1/24 443 verbose
Example6: python3 rdg_scanner_cve-2020-0609.py file:hostfile 443
     files can contain ips, hostnames, nets or AS

Usage: python3 rdg_scanner_cve-2020-0609.py targetip targetport
""")

def dummy():
    pass

vulnServers = []
counter = 0
thread = threading.Thread(target=dummy)
thread.start()

# parse our commands
parser = argparse.ArgumentParser()
parser.add_argument("target", help="server to check (defaults https)")
parser.add_argument("targetport", help="the target port (normally on 443)")
parser.add_argument("verbose", nargs="?", help="print out verbose information")
args = parser.parse_args()

# if we specify a verbose flag
if args.verbose:
    verbose = True
else: verbose = False

try:
    # specify file option to import host:port
    if "file" in (args.target):
        print("[*] Importing in list of hosts from filename: %s" % (args.target))
        with open(args.target.split(':')[1], 'r') as file:
            hosts= file.read().splitlines()
        for target_line in hosts:
            parse_target_args(target_line, args.targetport, verbose)
        # wait for the threads to complete
        thread.join()


    else:
        parse_target_args(args.target, args.targetport, verbose)

    # do a report on vuln servers
    print("Finished testing %s servers: Found %s to be RD Gateway. Below is a list system(s) identified:" % (counter, len(vulnServers)))
    print("-" * 45)
    for server in vulnServers:
        print(server)

except KeyboardInterrupt:
    print("[!] interrupt received, stopping..")
    time.sleep(0.1)

